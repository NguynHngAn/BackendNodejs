require("dotenv").config(); // S·ª≠ d·ª•ng bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env

const express = require("express");
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const cors = require("cors");
const { body, validationResult } = require("express-validator");
const bodyParser = require("body-parser");
const mqtt = require("mqtt");
const { spawn } = require("child_process");
const app = express();
const PORT = process.env.PORT || 8080;
const SECRET_KEY = process.env.JWT_SECRET || "luanvantotnghiep";
// ‚úÖ **Kh·ªüi t·∫°o WebSocket Server**
const WebSocket = require("ws");
const wss = new WebSocket.Server({ port: 8081 });
console.log("‚úÖ WebSocket server is running on ws://localhost:8081");
wss.on("connection", (ws) => {
  console.log("‚úÖ New WebSocket client connected");

  // Gi·ªØ WebSocket m·ªü b·∫±ng c√°ch g·ª≠i ping
  const keepAlive = setInterval(() => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.ping();
    }
  }, 30000);
  ws.on("pong", () => console.log("‚úÖ Pong received - WebSocket is alive"));
  ws.on("error", (error) => console.error("‚ùå WebSocket error:", error));
  ws.on("close", () => {
    clearInterval(keepAlive);
    console.log("‚ö†Ô∏è WebSocket client disconnected");
  });
});

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(express.json());

// K·∫øt n·ªëi MongoDB
const mongoURI = process.env.MONGO_URI;
(async () => {
  try {
    await mongoose.connect(mongoURI, { serverSelectionTimeoutMS: 30000, socketTimeoutMS: 45000 });
    console.log("Connected to MongoDB");
  } catch (err) {
    console.error("MongoDB connection error:", err);
    process.exit(1);
  }
})();

// **Schema v√† Model**
const sensorSchema = new mongoose.Schema({
  deviceID: String,
  force: Number,
  accel_x: Number,
  accel_y: Number,
  accel_z: Number,
  timestamp: { type: Date, default: Date.now },
});
const SensorData = mongoose.model("SensorData", sensorSchema);

const predictedSchema = new mongoose.Schema({
  deviceID: String,
  force: Number,
  accel_x: Number,
  accel_y: Number,
  accel_z: Number,
  predicted_force: Number,
  timestamp: { type: Date, default: Date.now },
});
const PredictedData = mongoose.model("predicteddatas", predictedSchema);

const userSchema = new mongoose.Schema({
  username: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  role: { type: String, default: "user" }, // ‚úÖ M·∫∑c ƒë·ªãnh l√† "user", c√≥ th·ªÉ l√† "admin"
});
const User = mongoose.model("Users", userSchema);

const deviceSchema = new mongoose.Schema({
  deviceID: { type: String, required: true, unique: true },
  name: { type: String}, // T√™n thi·∫øt b·ªã
  status: { type: String, default: "offline" }, // Tr·∫°ng th√°i thi·∫øt b·ªã
  lastUpdated: { type: Date, default: Date.now }, // L·∫ßn c·∫≠p nh·∫≠t cu·ªëi
  owner: { type: mongoose.Schema.Types.ObjectId, ref: "User", default: null } // Ch·ªß s·ªü h·ªØu thi·∫øt b·ªã (kh√¥ng d√πng unique)
});
const Device = mongoose.model("Device", deviceSchema);

// Middleware x√°c th·ª±c JWT
const authMiddleware = (req, res, next) => {
  const token = req.header("Authorization");
  if (!token) return res.status(401).json({ error: "Access Denied" });

  try {
    // L·∫•y token t·ª´ header Authorization
    const verified = jwt.verify(token.split(" ")[1], SECRET_KEY);
    req.user = verified; // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng v√†o request
    next();
  } catch (err) {
    return res.status(403).json({ error: "Invalid or Expired Token" });
  }
};

// MQTT Setup
const mqttBroker = process.env.MQTT_BROKER || "mqtt://localhost:1884";
const mqttClient = mqtt.connect(mqttBroker);
const statusTopic = "devices/+/status";
const dataTopic = "devices/+/data";

mqttClient.on("connect", () => {
  console.log("Connected to MQTT broker");
  mqttClient.subscribe([statusTopic, dataTopic], (err) => {
    if (err) console.error("Failed to subscribe to topics:", err);
    else console.log(`Subscribed to topics: ${statusTopic}, ${dataTopic}`);
  });
});

// Tr·∫°ng th√°i thi·∫øt b·ªã
let deviceStatus = { status: "offline", lastUpdated: null };

// X·ª≠ l√Ω d·ªØ li·ªáu t·ª´ MQTT
mqttClient.on("message", async (topic, message) => {
  try {
    const deviceID = topic.split("/")[1];
    const payload = message.toString();

    if (topic.includes("/status")) {
      // ‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i thi·∫øt b·ªã v√†o MongoDB
      await Device.findOneAndUpdate(
        { deviceID },
        { status: payload, lastUpdated: new Date() },
        { upsert: true, new: true }
      );

      console.log(`üì° Device ${deviceID} status updated: ${payload}`);

    } else if (topic.includes("/data")) {
      const sensorData = JSON.parse(payload);
      console.log(`üì• Received data from ${deviceID}:`, sensorData);

      // ‚úÖ G·ª≠i d·ªØ li·ªáu Live Data ƒë·∫øn WebSocket
      wss.clients.forEach((client) => {
        if (client.readyState === WebSocket.OPEN) {
          client.send(JSON.stringify({ deviceID, ...sensorData }));
          console.log("üì° Sent Live Data to WebSocket:", { deviceID, ...sensorData });
        }
      });
      // ‚úÖ L∆∞u d·ªØ li·ªáu v√†o MongoDB
      const newSensorData = new SensorData({ deviceID, ...sensorData });
      await newSensorData.save();
      console.log(`üíæ Sensor data from ${deviceID} saved to MongoDB`);

      // ‚úÖ G·ªçi Python script ƒë·ªÉ d·ª± ƒëo√°n d·ªØ li·ªáu
      const pythonProcess = spawn("python", ["predict_model.py", JSON.stringify(sensorData)]);

      pythonProcess.stdout.on("data", async (data) => {
        const output = data.toString().trim();
        
        if (output.includes("Predicted force")) {
          const predictedForce = parseFloat(output.split(":")[1].trim());
          console.log(`ü§ñ Prediction: Predicted force: ${predictedForce}`);

          // ‚úÖ L∆∞u d·ªØ li·ªáu d·ª± ƒëo√°n v√†o MongoDB
          const predictedData = new PredictedData({ deviceID, ...sensorData, predicted_force: predictedForce });
          await predictedData.save();
          console.log(`üíæ Predicted data from ${deviceID} saved to MongoDB`);

          // ‚úÖ G·ª≠i d·ªØ li·ªáu d·ª± ƒëo√°n ƒë·∫øn WebSocket
          wss.clients.forEach((client) => {
            if (client.readyState === WebSocket.OPEN) {
              client.send(JSON.stringify({ deviceID, ...sensorData, predicted_force: predictedForce }));
              console.log("üì° Sent Predicted Data to WebSocket:", { deviceID, ...sensorData, predicted_force: predictedForce });
            }
          });

        } else {
          console.error(`‚ö†Ô∏è Unexpected output from Python script: ${output}`);
        }
      });

      pythonProcess.stderr.on("data", (data) => {
        console.error(`‚ùå Error from Python script: ${data.toString()}`);
      });

      pythonProcess.on("close", (code) => {
        console.log(`‚úÖ Python process exited with code ${code}`);
      });
    }

  } catch (error) {
    console.error("‚ùå Error processing MQTT message:", error.message || error);
  }
});

// **API**
app.get('/', (req, res) => {
  res.send('Hello, Azure!');
});


app.get("/api/get-status", (req, res) => res.status(200).json(deviceStatus));

app.get("/api/get-data", authMiddleware, async (req, res) => {
  try {
    const { timeframe, deviceID } = req.query;
    const query = {};

    // L·ªçc theo thi·∫øt b·ªã c·ªßa ng∆∞·ªùi d√πng
    query.deviceID = { $in: req.user.devices }; // ƒê·∫£m b·∫£o req.user.devices ch·ª©a danh s√°ch deviceID c·ªßa ng∆∞·ªùi d√πng

    // L·ªçc theo th·ªùi gian n·∫øu c√≥
    if (timeframe) {
      const now = new Date();
      switch (timeframe) {
        case "1h":
          query.timestamp = { $gte: new Date(now - 60 * 60 * 1000) }; // 1 gi·ªù tr∆∞·ªõc
          break;
        case "24h":
          query.timestamp = { $gte: new Date(now - 24 * 60 * 60 * 1000) }; // 24 gi·ªù tr∆∞·ªõc
          break;
        case "1w":
          query.timestamp = { $gte: new Date(now - 7 * 24 * 60 * 60 * 1000) }; // 1 tu·∫ßn tr∆∞·ªõc
          break;
        case "1m":
          query.timestamp = { $gte: new Date(now.setMonth(now.getMonth() - 1)) }; // 1 th√°ng tr∆∞·ªõc
          break;
        default:
          break;
      }
    }

    // N·∫øu c√≥ deviceID ƒë∆∞·ª£c cung c·∫•p, l·ªçc theo deviceID
    if (deviceID) {
      query.deviceID = deviceID;
    }

    // T√¨m d·ªØ li·ªáu t·ª´ SensorData
    const data = await SensorData.find(query).sort({ timestamp: -1 });
    res.status(200).json(data);
  } catch (err) {
    console.error("Error fetching sensor data:", err);
    res.status(500).json({ error: "Failed to fetch sensor data" });
  }
});

app.get("/api/get-predicted-data", authMiddleware, async (req, res) => {
  try {
    const { timeframe, deviceID } = req.query;
    const query = {};

    // L·ªçc theo thi·∫øt b·ªã c·ªßa ng∆∞·ªùi d√πng
    query.deviceID = { $in: req.user.devices }; // ƒê·∫£m b·∫£o req.user.devices ch·ª©a danh s√°ch deviceID c·ªßa ng∆∞·ªùi d√πng

    // L·ªçc theo th·ªùi gian n·∫øu c√≥
    if (timeframe) {
      const now = new Date();
      switch (timeframe) {
        case "1h":
          query.timestamp = { $gte: new Date(now - 60 * 60 * 1000) }; // 1 gi·ªù tr∆∞·ªõc
          break;
        case "24h":
          query.timestamp = { $gte: new Date(now - 24 * 60 * 60 * 1000) }; // 24 gi·ªù tr∆∞·ªõc
          break;
        case "1w":
          query.timestamp = { $gte: new Date(now - 7 * 24 * 60 * 60 * 1000) }; // 1 tu·∫ßn tr∆∞·ªõc
          break;
        case "1m":
          query.timestamp = { $gte: new Date(now.setMonth(now.getMonth() - 1)) }; // 1 th√°ng tr∆∞·ªõc
          break;
        default:
          break;
      }
    }

    // N·∫øu c√≥ deviceID ƒë∆∞·ª£c cung c·∫•p, l·ªçc theo deviceID
    if (deviceID) {
      query.deviceID = deviceID;
    }

    // T√¨m d·ªØ li·ªáu d·ª± ƒëo√°n t·ª´ PredictedData
    const data = await PredictedData.find(query).sort({ timestamp: -1 });
    res.status(200).json(data);
  } catch (err) {
    console.error("Error fetching predicted data:", err);
    res.status(500).json({ error: "Failed to fetch predicted data" });
  }
});

app.get("/api/get-user-devices", authMiddleware, async (req, res) => {
  try {
    const userDevices = await Device.find({ owner: req.user.id });
    res.status(200).json(userDevices);
  } catch (error) {
    console.error("Error fetching user devices:", error);
    res.status(500).json({ error: "Failed to fetch devices" });
  }
});

app.get("/api/get-device-status", authMiddleware, async (req, res) => {
  try {
    const userDevices = await Device.find({ owner: req.user.id }).select("deviceID status lastUpdated");
    res.status(200).json(userDevices);
  } catch (error) {
    console.error("Error fetching device status:", error);
    res.status(500).json({ error: "Failed to fetch device status" });
  }
});

// API thi·∫øt b·ªã
app.get("/api/get-devices", authMiddleware, async (req, res) => {
  try {
    const devices = await SensorData.distinct("deviceID");
    res.status(200).json(devices);
  } catch (err) {
    console.error("Error fetching device list:", err);
    res.status(500).json({ error: "Failed to fetch device list" });
  }
});

// **API L·∫•y th√¥ng tin ng∆∞·ªùi d√πng**
app.get("/api/user", authMiddleware, async (req, res) => {
  try {
    // L·∫•y th√¥ng tin ng∆∞·ªùi d√πng t·ª´ ID trong token
    const user = await User.findById(req.user.id);
    if (!user) return res.status(404).json({ error: "User not found" });

    // Tr·∫£ v·ªÅ th√¥ng tin ng∆∞·ªùi d√πng
    res.json({ username: user.username, role: user.role });

  } catch (error) {
    console.error("Error fetching user:", error);
    res.status(500).json({ error: "Server error" });
  }
});

// ‚úÖ API: L·∫•y danh s√°ch t·∫•t c·∫£ users (Ch·ªâ admin m·ªõi ƒë∆∞·ª£c ph√©p truy c·∫≠p)
app.get("/api/admin/users", async (req, res) => {
  try {
    const token = req.header("Authorization").split(" ")[1]; // L·∫•y token
    const decoded = jwt.verify(token, SECRET_KEY); // Gi·∫£i m√£ token

    // Ki·ªÉm tra n·∫øu user l√† admin
    const adminUser = await User.findById(decoded.id);
    if (!adminUser || adminUser.role !== "admin") {
      return res.status(403).json({ error: "Access denied. Admin only." });
    }

    // ‚úÖ Tr·∫£ v·ªÅ danh s√°ch t·∫•t c·∫£ ng∆∞·ªùi d√πng
    const users = await User.find({}, { password: 0 }); // Kh√¥ng tr·∫£ v·ªÅ password
    res.json(users);
  } catch (error) {
    console.error("Error fetching users:", error);
    res.status(500).json({ error: "Server error" });
  }
});

// ‚úÖ API: L·∫•y danh s√°ch t·∫•t c·∫£ thi·∫øt b·ªã
app.get("/api/admin/devices", async (req, res) => {
  try {
    const devices = await Device.find({});
    res.status(200).json(devices); // Tr·∫£ v·ªÅ danh s√°ch thi·∫øt b·ªã cho admin
  } catch (error) {
    console.error("Error fetching devices:", error);
    res.status(500).json({ error: "Failed to fetch devices" });
  }
});

// L·∫•y danh s√°ch thi·∫øt b·ªã c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i (k√®m token x√°c th·ª±c)
app.get("/api/devices", authMiddleware, async (req, res) => {
  try {
    const userId = req.user.id; // ID ng∆∞·ªùi d√πng t·ª´ token
    const devices = await Device.find({ owner: userId });

    if (!devices || devices.length === 0) {
      return res.status(404).json({ message: "No devices found" });
    }

    res.status(200).json(devices);
  } catch (error) {
    console.error("Error fetching devices:", error);
    res.status(500).json({ message: "Internal Server Error", error: error.message });
  }
});

app.get("/api/users", async (req, res) => {
  try {
    const users = await User.find({}, "username email role"); // Tr·∫£ v·ªÅ c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
    res.json(users);
  } catch (err) {
    res.status(500).json({ error: "L·ªói khi l·∫•y danh s√°ch t√†i kho·∫£n" });
  }
});

app.get("/api/devices/unassigned", authMiddleware, async (req, res) => {
  try {
    const devices = await Device.find({ owner: null });
    res.status(200).json(devices);
  } catch (error) {
    res.status(500).json({ error: "L·ªói l·∫•y danh s√°ch thi·∫øt b·ªã ch∆∞a g√°n" });
  }
});

app.post("/api/devices/assign", authMiddleware, async (req, res) => {
  try {
    const { deviceID, userID } = req.body;

    // Ki·ªÉm tra t√†i kho·∫£n c√≥ t·ªìn t·∫°i kh√¥ng
    const user = await User.findById(userID);
    if (!user) return res.status(404).json({ error: "T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i" });

    // Ki·ªÉm tra thi·∫øt b·ªã c√≥ t·ªìn t·∫°i v√† ch∆∞a c√≥ ch·ªß s·ªü h·ªØu
    const device = await Device.findOne({ deviceID });
    if (!device) return res.status(404).json({ error: "Thi·∫øt b·ªã kh√¥ng t·ªìn t·∫°i" });
    if (device.owner) return res.status(400).json({ error: "Thi·∫øt b·ªã ƒë√£ c√≥ ch·ªß s·ªü h·ªØu" });

    // C·∫≠p nh·∫≠t ch·ªß s·ªü h·ªØu thi·∫øt b·ªã
    device.owner = userID;
    await device.save();

    res.status(200).json({ message: "G√°n thi·∫øt b·ªã th√†nh c√¥ng", device });
  } catch (error) {
    res.status(500).json({ error: "L·ªói khi g√°n thi·∫øt b·ªã" });
  }
});

app.get("/api/devices/by-user/:userID", authMiddleware, async (req, res) => {
  try {
    const userID = req.params.userID;
    const devices = await Device.find({ owner: userID });
    res.status(200).json(devices);
  } catch (error) {
    res.status(500).json({ error: "L·ªói khi l·∫•y thi·∫øt b·ªã c·ªßa ng∆∞·ªùi d√πng" });
  }
});

// ƒêƒÉng k√Ω ng∆∞·ªùi d√πng
app.post("/api/register", [
  body("username").notEmpty().withMessage("T√™n ng∆∞·ªùi d√πng kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng."),
  body("email").isEmail().withMessage("Email kh√¥ng h·ª£p l·ªá."),
  body("password").isLength({ min: 6 }).withMessage("M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±."),
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    // Tr·∫£ l·∫°i t·∫•t c·∫£ l·ªói d∆∞·ªõi d·∫°ng JSON ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt nguy√™n nh√¢n
    return res.status(400).json({ errors: errors.array() });
  }

  const { username, email, password } = req.body;
  const hashedPassword = await bcrypt.hash(password, 10);

  try {
    // Ki·ªÉm tra xem email c√≥ t·ªìn t·∫°i trong c∆° s·ªü d·ªØ li·ªáu hay kh√¥ng
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ error: "Email ƒë√£ t·ªìn t·∫°i. Vui l√≤ng s·ª≠ d·ª•ng email kh√°c." });
    }

    const newUser = new User({ username, email, password: hashedPassword, role: "user" });
    await newUser.save();
    res.status(201).json({ message: "ƒêƒÉng k√Ω ng∆∞·ªùi d√πng th√†nh c√¥ng" });
  } catch (err) {
    console.error("Registration error:", err);
    res.status(500).json({ error: err.message || "Server error" });
  }
});
// **ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng**
// ƒê·∫£m b·∫£o l·∫•y vai tr√≤ t·ª´ user khi ƒëƒÉng nh·∫≠p
// **ƒêƒÉng nh·∫≠p ng∆∞·ªùi d√πng**
app.post("/api/login", async (req, res) => {
  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ error: "User not found" });
    }

    // Ki·ªÉm tra m·∫≠t kh·∫©u v·ªõi bcrypt.compare()
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ error: "Invalid credentials" });
    }

    // T·∫°o JWT token, th√™m role v√†o token ƒë·ªÉ x√°c th·ª±c quy·ªÅn truy c·∫≠p
    const token = jwt.sign(
      { id: user._id, username: user.username, role: user.role },
      SECRET_KEY, // ƒê·∫£m b·∫£o r·∫±ng SECRET_KEY l√† ƒë√∫ng v√† b·∫£o m·∫≠t
      { expiresIn: "1h" } // Token h·∫øt h·∫°n sau 1 gi·ªù
    );

    // Tr·∫£ v·ªÅ token cho client
    res.json({ token });

  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: "Server error during login" });
  }
});

// Kh·ªüi ƒë·ªông server
app.listen(PORT, () => console.log(`Server is running on port ${PORT}`));